[
    {
        "repo_id": {
            "81": "apache/beam:11339"
        },
        "selected_nodeLs": {
            "81": "['PR-11339', 'PR-1151']"
        },
        "codediff": {
            "81": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<HttpBody> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<HttpBody>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      // write bundles of HttpBody to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(HttpBodyCoder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp file on GCS.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    /** The type Import fn. */\n+    static class WriteBundlesToFilesFn extends DoFn<HttpBody, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"/fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        this.resourceId = FileSystems.matchNewResource(this.tempGcsPath + filename, false);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        HttpBody httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody.getData(), Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<HttpBody>, Write.Result> {"
        },
        "groundTruth": {
            "81": "Is there any specific reason that the input is HttpBody instead of String? It feels weird to me because we only use the data field in the API client."
        },
        "ds_dnContext": {
            "81": "{\n  \"code_review_suggestion\": \"In the `WriteBundlesToFilesFn` class, the `@FinishBundle` method outputs the file resource ID even if no elements were processed in the bundle, which could create empty files and cause unnecessary import operations. Consider adding a check to only output the file if at least one element was written to it.\"\n}"
        },
        "model_names": "dsReasoner_No"
    },
    {
        "generated_comments": {
            "81": "{\n  \"code_review_suggestion\": \"The switch statement in Write.expand() lacks break statements after the IMPORT case, causing fall-through to EXECUTE_BUNDLE. This will execute both write methods unintentionally. Add a break after the import case to prevent this behavior.\"\n}"
        },
        "model_names": "dsReasoner_with"
    },
    {
        "generated_comments": {
            "81": "{\n  \"code_review_suggestion\": \"The switch statement in Write.expand() is missing break statements, causing fall-through behavior where IMPORT case will always execute the EXECUTE_BUNDLE logic too. Add explicit break statements to prevent unintended execution paths.\"\n}"
        },
        "model_names": "ds_No"
    },
    {
        "generated_comments": {
            "81": "{\n  \"code_review_suggestion\": \"The switch statement in Write.expand() is missing a break statement after the IMPORT case, causing fall-through to EXECUTE_BUNDLE which will incorrectly process failedBundles twice. Add a break statement after the IMPORT case to prevent this logical error.\"\n}"
        },
        "model_names": "ds_with"
    },
    {
        "generated_comments": {
            "81": "{\n  \"code_review_suggestion\": \"Great addition! I noticed a potential bug in the `Write.expand` method. The `switch` statement for the `IMPORT` case seems to fall through to the `EXECUTE_BUNDLE` case, which would cause the import logic to be overwritten and never actually run. Adding a `break;` statement to the `IMPORT"
        },
        "model_names": "gemini-2.5-pro_No"
    },
    {
        "generated_comments": {
            "81": "{\n  \"code_review_suggestion\": \"This is a great addition for Healthcare API users! I noticed a potential bug in the `Write.expand` method. It looks like the `case IMPORT:` in the switch statement is missing a `break`, which causes it to fall through and execute the `EXECUTE_BUNDLE` logic instead. Adding a `break;` should"
        },
        "model_names": "gemini-2.5-pro_with"
    },
    {
        "generated_comments": {
            "81": "{\n  \"code_review_suggestion\": \"In the Write.expand() method, the switch case for IMPORT does not include a break statement, causing it to unintentionally fall through to EXECUTE_BUNDLE and override the failedBundles variable; adding a break after the IMPORT case will fix this bug and clarify control flow.\"\n}"
        },
        "model_names": "gpt-4.1-mini_No"
    },
    {
        "generated_comments": {
            "81": "{\n  \"code_review_suggestion\": \"Consider avoiding the fall-through logic in the Write.expand() method's switch statement, as it leads to the executeBundles transform being applied unconditionally even after the import method, which can cause unexpected behavior. Refactor to clearly separate the IMPORT and EXECUTE_BUNDLE cases for better clarity and correctness.\"\n}"
        },
        "model_names": "gpt-4.1-mini_with"
    },
    {
        "generated_comments": {
            "81": "{\"code_review_suggestion\":\"In Write.expand(), the switch intentionally (comment) falls through from IMPORT to EXECUTE_BUNDLE, causing every IMPORT run to also execute bundles and overwrite failedBundles—duplicating writes and losing the import errors. Add a break or return after the IMPORT branch (or separate the logic) so IMPORT and EXECUTE_BUNDLE are mutually exclusive and preserve the correct failedBundles output.\"}"
        },
        "model_names": "gpt-5_No"
    },
    {
        "generated_comments": {
            "81": "{\"code_review_suggestion\":\"In Write.expand(), the switch on getWriteMethod() intentionally or accidentally falls through: after IMPORT you set failedBundles from Import but then continue into EXECUTE_BUNDLE and overwrite it, effectively executing both paths and likely double-writing. Add an explicit break (or convert to if/else) after the IMPORT case to preserve the intended mutually exclusive behavior.\"}"
        },
        "model_names": "gpt-5_with"
    }
]