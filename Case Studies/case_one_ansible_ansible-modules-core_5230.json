[
    {
        "repo_id": {
            "161": "ansible/ansible-modules-core:5230"
        },
        "selected_nodeLs": {
            "161": "['PR-4517', 'PR-5230']"
        },
        "codediff": {
            "161": "@@ -255,148 +343,136 @@ def main():\n         argument_spec=argument_spec,\n         mutually_exclusive=[['template_url', 'template']],\n     )\n-    if not HAS_BOTO:\n-        module.fail_json(msg='boto required for this module')\n+    if not HAS_BOTO3:\n+        module.fail_json(msg='boto3 required for this module')\n \n+    # collect the parameters that are passed to boto3. Keeps us from having so many scalars floating around.\n+    stack_params = {\n+      'Capabilities':['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'],\n+    }\n     state = module.params['state']\n-    stack_name = module.params['stack_name']\n+    stack_params['StackName'] = module.params['stack_name']\n \n     if module.params['template'] is None and module.params['template_url'] is None:\n         if state == 'present':\n-            module.fail_json('Module parameter \"template\" or \"template_url\" is required if \"state\" is \"present\"')\n+            module.fail_json(msg='Module parameter \"template\" or \"template_url\" is required if \"state\" is \"present\"')\n \n     if module.params['template'] is not None:\n-        template_body = open(module.params['template'], 'r').read()\n-    else:\n-        template_body = None\n+        stack_params['TemplateBody'] = open(module.params['template'], 'r').read()\n \n     if module.params['template_format'] == 'yaml':\n-        if template_body is None:\n+        if not stack_params.get('TemplateBody'):\n             module.fail_json(msg='yaml format only supported for local templates')\n         else:\n-            template_body = json.dumps(yaml.load(template_body), indent=2)\n+            stack_params['TemplateBody'] = json.dumps(yaml.load(stack_params['TemplateBody']), indent=2)\n \n-    notification_arns = module.params['notification_arns']\n+    if module.params.get('notification_arns'):\n+        stack_params['NotificationARNs'] = module.params['notification_arns'].split(',')\n+    else:\n+        stack_params['NotificationARNs'] = []\n \n     if module.params['stack_policy'] is not None:\n-        stack_policy_body = open(module.params['stack_policy'], 'r').read()\n-    else:\n-        stack_policy_body = None\n+        stack_params['StackPolicyBody'] = open(module.params['stack_policy'], 'r').read()\n \n-    disable_rollback = module.params['disable_rollback']\n     template_parameters = module.params['template_parameters']\n-    tags = module.params['tags']\n-    template_url = module.params['template_url']\n-\n-    region, ec2_url, aws_connect_kwargs = get_aws_connection_info(module)\n+    stack_params['Parameters'] = [{'ParameterKey':k, 'ParameterValue':v} for k, v in template_parameters.items()]\n \n-    kwargs = dict()\n-    if tags is not None:\n-        if not boto_version_required((2,6,0)):\n-            module.fail_json(msg='Module parameter \"tags\" requires at least Boto version 2.6.0')\n-        kwargs['tags'] = tags\n+    if isinstance(module.params.get('tags'), dict):\n+        stack_params['Tags'] = ansible.module_utils.ec2.ansible_dict_to_boto3_tag_list(module.params['tags'])\n \n+    if module.params.get('template_url'):\n+        stack_params['TemplateURL'] = module.params['template_url']\n \n-    # convert the template parameters ansible passes into a tuple for boto\n-    template_parameters_tup = [(k, v) for k, v in template_parameters.items()]\n-    stack_outputs = {}\n+    update = False\n+    result = {}\n \n     try:\n-        cfn = connect_to_aws(boto.cloudformation, region, **aws_connect_kwargs)\n-    except boto.exception.NoAuthHandlerFound as e:\n+        region, ec2_url, aws_connect_kwargs = ansible.module_utils.ec2.get_aws_connection_info(module, boto3=True)\n+        cfn = ansible.module_utils.ec2.boto3_conn(module, conn_type='client', resource='cloudformation', region=region, endpoint=ec2_url, **aws_connect_kwargs)\n+    except botocore.exceptions.NoCredentialsError as e:\n         module.fail_json(msg=str(e))\n-    update = False\n-    result = {}\n-    operation = None\n+\n+    stack_info = get_stack_facts(cfn, stack_params['StackName'])\n \n     # if state is present we are going to ensure that the stack is either\n     # created or updated\n-    if state == 'present':\n+    if state == 'present' and not stack_info:\n         try:\n-            cfn.create_stack(stack_name, parameters=template_parameters_tup,\n-                             template_body=template_body,\n-                             notification_arns=notification_arns,\n-                             stack_policy_body=stack_policy_body,\n-                             template_url=template_url,\n-                             disable_rollback=disable_rollback,\n-                             capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'],\n-                             **kwargs)\n-            operation = 'CREATE'\n+            # 'disablerollback' only applies on creation, not update.\n+            stack_params['DisableRollback'] = module.params['disable_rollback']\n+\n+            cfn.create_stack(**stack_params)\n         except Exception as err:\n             error_msg = boto_exception(err)\n-            if 'AlreadyExistsException' in error_msg or 'already exists' in error_msg:\n-                update = True\n-            else:\n-                module.fail_json(msg=error_msg)\n-        if not update:\n-            result = stack_operation(cfn, stack_name, operation)\n-\n-    # if the state is present and the stack already exists, we try to update it\n-    # AWS will tell us if the stack template and parameters are the same and\n-    # don't need to be updated.\n-    if update:\n+            #return {'error': error_msg}\n+            module.fail_json(msg=error_msg)\n+        result = stack_operation(cfn, stack_params['StackName'], 'CREATE')\n+        if not result: module.fail_json(msg=\"empty result\")\n+\n+    if state == 'present' and stack_info:\n+        # if the state is present and the stack already exists, we try to update it.\n+        # AWS will tell us if the stack template and parameters are the same and\n+        # don't need to be updated.\n         try:\n-            cfn.update_stack(stack_name, parameters=template_parameters_tup,\n-                             template_body=template_body,\n-                             notification_arns=notification_arns,\n-                             stack_policy_body=stack_policy_body,\n-                             disable_rollback=disable_rollback,\n-                             template_url=template_url,\n-                             capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'],\n-                             **kwargs)\n-            operation = 'UPDATE'\n+            cfn.update_stack(**stack_params)\n         except Exception as err:\n             error_msg = boto_exception(err)\n             if 'No updates are to be performed.' in error_msg:\n                 result = dict(changed=False, output='Stack is already up-to-date.')\n             else:\n                 module.fail_json(msg=error_msg)\n-\n-        if operation == 'UPDATE':\n-            result = stack_operation(cfn, stack_name, operation)\n+                #return {'error': error_msg}\n+                #module.fail_json(msg=error_msg)\n+        result = stack_operation(cfn, stack_params['StackName'], 'UPDATE')\n+        if not result: module.fail_json(msg=\"empty result\")\n \n     # check the status of the stack while we are creating/updating it.\n     # and get the outputs of the stack\n \n     if state == 'present' or update:\n-        stack = invoke_with_throttling_retries(cfn.describe_stacks,stack_name)[0]\n-        for output in stack.outputs:\n-            stack_outputs[output.key] = output.value\n-        result['stack_outputs'] = stack_outputs\n-        stack_resources = [] \n-        for res in cfn.list_stack_resources(stack_name):\n+        stack = get_stack_facts(cfn, stack_params['StackName'])\n+        for output in stack.get('Outputs', []):\n+            result['stack_outputs'][output['OutputKey']] = output['OutputValue']\n+        stack_resources = []\n+        reslist = cfn.list_stack_resources(StackName=stack_params['StackName'])\n+        for res in reslist.get('StackResourceSummaries', []):\n             stack_resources.append({\n-                \"last_updated_time\": res.last_updated_time,\n-                \"logical_resource_id\": res.logical_resource_id,\n-                \"physical_resource_id\": res.physical_resource_id,\n-                \"status\": res.resource_status,\n-                \"status_reason\": res.resource_status_reason,\n-                \"resource_type\": res.resource_type })\n+                \"logical_resource_id\": res['LogicalResourceId'],\n+                \"physical_resource_id\": res['PhysicalResourceId'],\n+                \"resource_type\": res['ResourceType'],\n+                \"last_updated_time\": res['LastUpdatedTimestamp'],\n+                \"status\": res['ResourceStatus'],\n+                \"status_reason\": res.get('ResourceStatusReason') # can be blank, apparently\n+            })\n         result['stack_resources'] = stack_resources\n \n     # absent state is different because of the way delete_stack works.\n     # problem is it it doesn't give an error if stack isn't found\n     # so must describe the stack first\n \n     if state == 'absent':\n+        #result = {}\n         try:\n-            invoke_with_throttling_retries(cfn.describe_stacks,stack_name)\n-            operation = 'DELETE'\n-        except Exception as err:\n-            error_msg = boto_exception(err)\n-            if 'Stack:%s does not exist' % stack_name in error_msg:\n+            stack = get_stack_facts(cfn, stack_params['StackName'])\n+            if not stack:\n                 result = dict(changed=False, output='Stack not found.')\n             else:\n-                module.fail_json(msg=error_msg)\n-        if operation == 'DELETE':\n-            cfn.delete_stack(stack_name)\n-            result = stack_operation(cfn, stack_name, operation)\n+                cfn.delete_stack(StackName=stack_params['StackName'])\n+                result = stack_operation(cfn, stack_params['StackName'], 'DELETE')\n+        except Exception as err:\n+            ei = sys.exc_info()\n+            error_msg = boto_exception(err)\n+            module.fail_json(msg=error_msg + ' ' + str(traceback.format_exception(*ei)))"
        },
        "groundTruth": {
            "161": "Instead of stringifying the traceback, use the `exception` kwarg to `fail_json`. It takes the formatted traceback (which doesn't require an arg inside an exception handler). ``` except Exception as err: module.fail_json(msg=boto_exception(err), exception=traceback.format_exc()) ```"
        },
        "ds_dnContext": {
            "161": "{\n  \"code_review_suggestion\": \"The code fails to initialize the 'stack_outputs' dictionary in the result when collecting stack outputs, which would cause a KeyError when trying to assign output values. Initialize result['stack_outputs'] as an empty dictionary before the loop that populates it.\"\n}"
        },
        "model_names": "dsReasoner_No"
    },
    {
        "generated_comments": {
            "161": "{\n  \"code_review_suggestion\": \"The create_stack call might fail with AlreadyExistsException if the stack was created after the initial existence check. Consider adding error handling for this case to trigger an update instead of failing completely, similar to the previous boto implementation.\"\n}"
        },
        "model_names": "dsReasoner_with"
    },
    {
        "generated_comments": {
            "161": "{\n  \"code_review_suggestion\": \"The code is missing proper error handling for file operations when reading template and stack policy files. You should use context managers (with open()) to ensure files are properly closed even if exceptions occur, and add validation to handle file not found or permission errors gracefully.\"\n}"
        },
        "model_names": "ds_No"
    },
    {
        "generated_comments": {
            "161": "{\n    \"code_review_suggestion\": \"The error handling in the stack deletion logic is inconsistent with the rest of the module. While other operations use `module.fail_json(msg=error_msg)`, the delete operation includes a full traceback which exposes internal details. Consider using the same clean error reporting pattern: `module.fail_json(msg=error_msg)` instead of including the traceback.\"\n}"
        },
        "model_names": "ds_with"
    },
    {
        "generated_comments": {
            "161": "{\n  \"code_review_suggestion\": \"Nice refactor to boto3! One quick suggestion: the template and stack policy files are opened but not explicitly closed. Using a `with open(...)` block would be safer, as it guarantees the files are closed automatically and prevents potential resource leaks.\"\n}"
        },
        "model_names": "gemini-2.5-pro_No"
    },
    {
        "generated_comments": {
            "161": "{\n  \"code_review_suggestion\": \"This is a fantastic refactor to boto3! One small improvement: for reading the template and stack policy files, it would be safer to use a `with` statement (e.g., `with open(...) as f:`). This guarantees the files are closed automatically, preventing potential resource leaks, especially if an error occurs.\"\n}"
        },
        "model_names": "gemini-2.5-pro_with"
    },
    {
        "generated_comments": {
            "161": "{\n  \"code_review_suggestion\": \"The key issue is directly reading files without proper error handling and resource management (e.g., using open()). This can cause silent failures or resource leaks if files are missing or unreadable. Wrap file operations in try-except blocks and use context managers (with open(...)) to ensure safe, clean file handling.\"\n}"
        },
        "model_names": "gpt-4.1-mini_No"
    },
    {
        "generated_comments": {
            "161": "{\n  \"code_review_suggestion\": \"Great update fixing fail_json usage and migrating to boto3! Consider simplifying file reads with context managers to ensure files are properly closed and avoid potential resource leaks.\"\n}"
        },
        "model_names": "gpt-4.1-mini_with"
    },
    {
        "generated_comments": {
            "161": "{\"code_review_suggestion\":\"result['stack_outputs'] is written to before being initialized, causing a KeyError. Initialize it (e.g. result.setdefault('stack_outputs', {})) before the loop adding outputs so the code wonâ€™t blow up on stacks with outputs.\"}"
        },
        "model_names": "gpt-5_No"
    },
    {
        "generated_comments": {
            "161": "{\"code_review_suggestion\":\"result['stack_outputs'] is referenced before being initialized (the previous stack_outputs = {} setup was removed), which will raise a KeyError when adding outputs. Initialize result['stack_outputs'] = {} right after creating result (and before the outputs loop) to avoid the crash.\"}"
        },
        "model_names": "gpt-5_with"
    }
]